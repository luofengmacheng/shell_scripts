## 变量的若干问题

### 1 输入的参数变量($#、$*、$@)

* `$#` 输入参数的个数
* `$*` 输入的位置参数被当作一个单词处理
* `$@` 输入的位置参数中的每个参数被当作一个独立的字符串

当然，上面的`$*`和`$@`的解释是有条件的：

当`$*`和`$@`没有被双引号引用时，参数中的每个参数被当作独立的字符串。只有当它们被双引号引用时，才会有以上的解释。

因此，`$*`就像是直接将参数字符串放到该变量中，而`$@`就像是在每个参数的两边都添加了双引号。

* `$*` = arg1 arg2 arg3
* `$@` = "arg1" "arg2" "arg3"

备注：`只有使用引号时，$*和$@表示的意义才不一样`

### 2 IFS

#### 2.1 IFS是什么

IFS是一个变量，是字符串的定界符，for循环、read在读取字符串时都会使用它对字符串进行分割，分割得到的每个部分就是读取的一个元素。

当采用默认设置或者设置IFS为空时，IFS就是空白符(空格、换行、制表符)。

#### 2.2 IFS对$*和$@的影响

```shell
output_args_one_per_line()
{
	echo "$*"
	echo $*
	echo "$@"
	echo $@

	for arg
	do
		echo "[$arg]"
	done
}

IFS=" "
var=" a  b c  "
output_args_one_per_line $var

echo

IFS=:
var=":a::b:::"
output_args_one_per_line $var
```

这段代码输出：

```shell
a b c
a b c
a b c
a b c
[a]
[b]
[c]

:a::b::
 a  b
 a  b
 a  b
[]
[a]
[]
[b]
[]
[]
```

根据以上的结果可以得出推论：

```
"$*" 用IFS分割，用IFS中第一个字符进行连接
$* "$@" $@ 用IFS分割，用空格进行连接
```