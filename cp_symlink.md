## 记一次cp软链接的坑

### 1 事件起因

一次在进行发布测试的过程中，发现所发布的机器宕机了，起初怀疑是由于包的大小，导致发布服务器宕机了，因为，另一个包很顺畅地发布了，然后，又重新发布了两次都出现了这个问题。最后，将该包发布到另外6台服务器，结果有4台出了问题，其中两台宕机了。

### 2 排查

查看另外两台没有宕掉的服务器，发现负载很高，看进程时发现它在重复启动一个脚本，而且是自己启动自己，而我们只调用了一次该脚本。排查了半天，实在没办法，只有请高人出马了，最后，还是高人发现了问题所在：软链接在进行拷贝时，修改了链接的目标程序，导致了循环。

### 3 原因详解

由于已经发布过一次，因此，在目标机器上已经有了两个文件，假设是a_dest和b_dest，其中a_dest是个程序，b_dest是个链接，指向a_dest。进行再次发布时，由于运维人员的疏忽，导致b_source是个普通文件，它的内容是a_source文件的路径。因此，在进行拷贝时，如果先拷贝a_source到目标a_dest，这两个文件都是普通程序，并没有问题，然后拷贝b_source到目标b_dest，由于目标b_dest是个链接，因此，会将b_source的内容(a_source的文件路径)拷贝到目标b_dest链接的文件(a_dest)，结果就是：b_dest链接的文件a_dest的内容是a_source文件的路径(其实也是a_dest的路径)，即一个文件的内容是它自己的路径。

注意：a_source和a_dest的文件名相同，b_source和b_dest的文件名相同，只是为了标识源和目的。

如下图所示：

拷贝前：

![](https://github.com/luofengmacheng/shell_scripts/blob/master/pics/cpsymlink1.png)

拷贝后：

![](https://github.com/luofengmacheng/shell_scripts/blob/master/pics/cpsymlink2.png)

此时，如果一个脚本调用b_dest时，实际执行的是a_dest，而a_dest中内容是a_dest的路径又会执行a_dest文件，即自己调用自己，从而造成了一个无限循环。

### 4 cp命令

cp命令如果不加`递归`选项，则会跟随软链接，访问实际的文件。如果加上递归选项，就不会跟随软链接。因此，就有以下特殊情况：

* cp link dest 没有添加递归选项，就会跟随链接，拷贝的就是链接指向的实际文件
* cp -r link dest 添加了递归选项，就会拷贝链接本身
* cp -r dir1 dest 递归拷贝文件夹，文件夹中如果是链接，就拷贝链接本身
* cp dir/* dest 没有添加递归选项，就会跟随链接，拷贝的就是链接指向的实际文件
* cp -r dir/* dest 添加了递归选项，就会拷贝链接本身

### 5 收获

通过这个事情，有一些收获：

* 遇到事情不能靠猜测。最开始，我们还怀疑是机器的问题。
* 在处理文件时，要特别注意链接等特殊文件。